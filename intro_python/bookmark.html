<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                              "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en"
	lang="en">
	<head>
                <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
                <!-- HTML5 -->
                <meta charset="UTF-8"/>
		<style type="text/css">
                    .bodyContainer {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    padding-left: 32px;
    padding-right: 32px;
}

.notebookFor {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin: 24px 0px 0px;
    padding: 0px;
}

.bookTitle {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    padding: 0px;
}

.authors {
    font-size: 13px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin-top: 22px;
    margin-bottom: 24px; 
    padding: 0px;
}

.citation {
    font-size: 16px;
    font-weight: 500;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    margin-bottom: 24px;
    padding: 0px;
}

.sectionHeading {
    font-size: 24px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 24px;
    padding: 0px;
}

.noteHeading {
    font-size: 18px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 20px;
    padding: 0px;
}

.noteText {
    font-size: 18px;
    font-weight: 500;
    text-align: left;
    color: #333333;
    margin: 2px 0px 0px;
    padding: 0px;
}

.highlight_blue {
    color: rgb(178, 205, 251);
}

.highlight_orange {
    color: #ffd7ae;
}

.highlight_pink {
    color: rgb(255, 191, 206);
}

.highlight_yellow {
    color: rgb(247, 206, 0);
}

.notebookGraphic {
    margin-top: 10px;
    text-align: left;
}

.notebookGraphic img {
    -o-box-shadow:      0px 0px 5px #888;
    -icab-box-shadow:   0px 0px 5px #888;
    -khtml-box-shadow:  0px 0px 5px #888;
    -moz-box-shadow:    0px 0px 5px #888;
    -webkit-box-shadow: 0px 0px 5px #888;
    box-shadow:         0px 0px 5px #888; 
    max-width: 100%;
    height: auto;
}

hr {
    border: 0px none;
    height: 1px;
    background: none repeat scroll 0% 0% rgb(221, 221, 221);
}

		</style>
		<script type="text/javascript">
		    
		</script>
		<title></title>
	</head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
笔记本
</div>
<div class="bookTitle">
Python语言及其应用
</div>
<div class="authors">
[美] Bill Lubanovic
</div>
<div class="citation">
Citation (APA): Lubanovic, [. B. (2018). <i>Python语言及其应用</i> [Kindle Android version]. Retrieved from Amazon.com
</div>
<hr />

            <div class="sectionHeading">
2.3.8　使用len()获得长度
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 1269
</div>
<div class="noteText">
使用 len()获得长度
</div>
<div class="sectionHeading">
2.3.9　使用split()分割
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 1279
</div>
<div class="noteText">
使用 split()分割
</div>
<div class="sectionHeading">
2.3.10　使用join()合并
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 1297
</div>
<div class="noteText">
使用 join()合并可能你已经猜到了， join()函数与 split()函数正好相反：它将包含若干子串的列表分解，并将这些子串合成一个完整的大的字符串。 join()的调用顺序看起来有点别扭，与 split()相反，你需要首先指定粘合用的字符串，然后再指定需要合并的列表： string. join( list)。因此，为了将列表 lines中的多个子串合并成完整的字符串，我们应该使用语句：'\ n'. join( lines)。下面的例子将列表中的名字通过逗号及空格粘合在一起：
</div>
<div class="sectionHeading">
2.3.12　大小写与对齐方式
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 1345
</div>
<div class="noteText">
字符串收尾的 .都删除掉： >>> setup. strip('.') 'a duck goes into a bar'
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 1349
</div>
<div class="noteText">
由于字符串是不可变的，上面这些例子实际上没有一个对 setup真正做了修改。它们都仅仅是获取了 setup的值，进行某些操作后将操作结果赋值给了另一个新的字符串而已。
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 1356
</div>
<div class="noteText">
>>> setup. title() 'A Duck Goes Into A Bar...'让所有字母都变成大写： >>> setup. upper() 'A DUCK GOES INTO A BAR...'将所有字母转换成小写： >>> setup. lower() 'a duck goes into a bar...'将所有字母的大小写转换： >>> setup. swapcase() 'a DUCK GOES INTO A BAR...'
</div>
<div class="sectionHeading">
2.3.13　使用replace()替换
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 1378
</div>
<div class="noteText">
使用 replace()替换
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 1381
</div>
<div class="noteText">
最后一个参数如果省略则默认只替换第一次出现的位置： >>> setup. replace(' duck', 'marmoset') 'a marmoset goes into a bar...'修改最多 100处： >>> setup. replace(' a ', 'a famous ', 100) 'a famous duck goes into a famous bar...'
</div>
<div class="sectionHeading">
3.2.16　使用join()转换为字符串
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 1639
</div>
<div class="noteText">
>>> marxes = ['Groucho', 'Chico', 'Harpo'] >>> ', '.join( marxes) 'Groucho, Chico, Harpo'等等，你可能会觉得 join()的使用顺序看起来有点别扭。这是因为 join()实际上是一个字符串方法，而不是列表方法。不能通过 marxes. join(',')进行调用，尽管这可能看起来更直观。 join()函数的参数是字符串或者其他可迭代的包含字符串的序列（例如上面例子中的字符串列表），它的输出是一个字符串。如果 join()是列表方法，将无法对其他可迭代的对象（例如元组、字符串）使用。如果坚持想让它能接受任何迭代类型，你必须亲自为每一种类型的序列编写合并代码，这太过费力。试着这样来记忆 join()的调用顺序： join()是 split()的逆
</div>
<div class="sectionHeading">
3.4.2　使用dict()转换为字典
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 1793
</div>
<div class="noteText">
3. 4. 2 使用 dict()转换为字典可以用 dict()将包含双值子序列的序列转换成字典。（你可能会经常遇到这种子序列，例如“ Strontium， 90， Carbon， 14”或者“ Vikings， 20， Packers， 7”，等等。）每个子序列的第一个元素作为键，第二个元素作为值。首先，这里有一个使用 lol（ a list of two- item list）创建字典的小例子： >>> lol = [ ['a', 'b'], ['c', 'd'], ['e', 'f'] ] >>> dict( lol) {'c': 'd', 'a': 'b', 'e': 'f'} 记住，字典中元素的顺序是无关紧要的，实际存储顺序可能取决于你添加元素的顺序。
</div>
<div class="sectionHeading">
4.5.4　使用zip()并行迭代
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2501
</div>
<div class="noteText">
使用 zip()并行迭代
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2502
</div>
<div class="noteText">
在使用迭代时，有一个非常方便的技巧：通过 zip()函数对多个序列进行并行迭代： >>> days = ['Monday', 'Tuesday', 'Wednesday'] >>> fruits = ['banana', 'orange', 'peach'] >>> drinks = ['coffee', 'tea', 'beer'] >>> desserts = ['tiramisu', 'ice cream', 'pie', 'pudding'] >>> for day, fruit, drink, dessert in zip( days, fruits, drinks, desserts): ... print( day, ": drink", drink, "- eat", fruit, "- enjoy", dessert) ... Monday : drink coffee - eat banana - enjoy tiramisu Tuesday : drink tea - eat orange - enjoy ice cream Wednesday : drink beer - eat peach - enjoy pie zip()函数在最短序列“用完”时就会停止。上面例子中的列表（ desserts）是最长的，所以我们无法填充列表，除非人工扩展其他列表。
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2518
</div>
<div class="noteText">
现在使用 zip()函数配对两个元组。函数的返回值既不是元组也不是列表，而是一个整合在一起的可迭代变量： >>> list( zip( english, french) ) [('Monday', 'Lundi'), ('Tuesday', 'Mardi'), ('Wednesday', 'Mercredi')]
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2522
</div>
<div class="noteText">
配合 dict()函数和 zip()函数的返回值就可以得到一本微型的英法词典： >>> dict( zip( english, french) ) {'Monday': 'Lundi', 'Tuesday': 'Mardi', 'Wednesday': 'Mercredi'}
</div>
<div class="sectionHeading">
4.6　推导式
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2559
</div>
<div class="noteText">
推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。它可以将循环和条件判断结合，从而避免语法冗长的代码。会使用推导式有时可以说明你已经超过 Python初学者的水平。也就是说，使用推导式更像 Python风格。
</div>
<div class="sectionHeading">
4.6.1　列表推导式
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2576
</div>
<div class="noteText">
Python风格的创建列表方式是使用列表推导。最简单的形式如下所示： [ expression for item in iterable
</div>
<div class="sectionHeading">
4.6.3　集合推导式
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2641
</div>
<div class="noteText">
 集合推导式
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2644
</div>
<div class="noteText">
{expression for expression in iterable }
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2645
</div>
<div class="noteText">
最长的版本（ if tests, multiple for clauses）对于集合而言也是可行的： >>> a_ set = {number for number in range( 1, 6) if number % 3 == 1} >>> a_ set {1, 4}
</div>
<div class="sectionHeading">
4.6.4　生成器推导式
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2650
</div>
<div class="noteText">
生成器推导式元组是没有推导式的。你可能认为将列表推导式中的方括号变成圆括号就可以定义元组推导式，就像下面的表达式一样： >>> number_ thing = (number for number in range( 1, 6))
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2653
</div>
<div class="noteText">
其实，圆括号之间的是生成器推导式，它返回的是一个生成器对象： >>> type( number_ thing) < class 'generotor'> 4. 8节会详细介绍。它是将数据传给迭代器的一种方式。
</div>
<div class="sectionHeading">
4.7.3　指定默认参数值
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2814
</div>
<div class="noteText">
默认参数值在函数被定义时已经计算出来，而不是在程序运行时。 Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当作默认参数
</div>
<div class="sectionHeading">
4.7.4　使用*收集位置参数
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2832
</div>
<div class="noteText">
 使用*收集位置参数
</div>
<div class="sectionHeading">
4.7.5　使用**收集关键字参数
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 2856
</div>
<div class="noteText">
使用**收集关键字参数
</div>
<div class="sectionHeading">
4.8　生成器
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3048
</div>
<div class="noteText">
如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这时可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield语句声明而不是 return。下面编写我们自己的 range()函数版本： >>> def my_ range( first= 0, last= 10, step= 1): ... number = first ... while number < last: ... yield number ... number += step
</div>
<div class="sectionHeading">
4.9　装饰器
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3066
</div>
<div class="noteText">
装饰器实质上是一个函数。它把一个函数作为输入并且返回另外一个函数。在装饰器中，通常使用下面这些 Python技巧： *args和 **kwargs闭包作为参数的函数
</div>
<div class="sectionHeading">
4.11　使用try和except处理错误
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3182
</div>
<div class="noteText">
Do, or do not. There is no try.”
</div>
<div class="sectionHeading">
5.5.1　使用setdefault()和defaultdict()处理缺失的键
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3439
</div>
<div class="noteText">
使用 setdefault()和 defaultdict()处理缺失的键
</div>
<div class="sectionHeading">
5.5.2　使用Counter()计数
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3497
</div>
<div class="noteText">
5. 5. 2 使用 Counter()计数
</div>
<div class="sectionHeading">
5.5.3　使用有序字典OrderedDict()按键排序
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3538
</div>
<div class="noteText">
OrderedDict()按键排序在前面几章的代码示例中可以看出，
</div>
<div class="sectionHeading">
5.5.4　双端队列：栈+队列
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3561
</div>
<div class="noteText">
def palindrome( word): ... from collections import deque ... dq = deque( word) ... while len( dq) > 1: ... if dq. popleft() != dq. pop(): ... return False ... return True ... ... >>> palindrome(' a') True >>> palindrome(' racecar')
</div>
<div class="sectionHeading">
6.6　使用super从父类得到帮助
</div>
<div class="noteHeading">
标注 (<span class="highlight_orange">橙色</span>) -  位置 3841
</div>
<div class="noteText">
 使用 super从父类得到帮助我们已经知道如何在子类中覆盖父类的方法，
</div>
<div class="sectionHeading">
6.8　使用属性对特性进行访问和设置
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3911
</div>
<div class="noteText">
使用属性对特性进行访问和设置
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3929
</div>
<div class="noteText">
name = property( get_ name, set_ name)
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3950
</div>
<div class="noteText">
另一种定义属性的方式是使用修饰符（ decorator）。
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3952
</div>
<div class="noteText">
@property，用于指示 getter方法； @name. setter，用于指示 setter方法。
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 3998
</div>
<div class="noteText">
如前面例子中，假如我们需要把特性 hidden_ name的名字改成 in_ class_ name。不设置属性（ property）的话，我们需要在每一处访问 hidden_ name的地方将它替换
</div>
<div class="sectionHeading">
6.9　使用名称重整保护私有特性
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4005
</div>
<div class="noteText">
前面的 Duck例子中，为了隐藏内部特性，我们曾将其命名为 hidden_ name。其实， Python对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头（__）。
</div>
<div class="sectionHeading">
6.10　方法的类型
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4055
</div>
<div class="noteText">
这种类型的方法被称作静态方法（ static method），用 @staticmethod修饰，
</div>
<div class="sectionHeading">
7.1.3　使用正则表达式匹配
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4884
</div>
<div class="noteText">
>>> import string >>> printable = string. printable
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4897
</div>
<div class="noteText">
>>> re. findall('\ s', printable) [' ', '\t', '\n', '\r', '\x0b', '\x0c']
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4917
</div>
<div class="noteText">
模式匹配 abc文本值 abc（expr） expr expr 1 | expr 2 expr 1或 expr 2 .除 \n外的任何字符 ^源字符串的开头
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4931
</div>
<div class="noteText">
$源字符串的结尾 prev? 0个或 1个 prev prev* 0个或多个 prev，尽可能多地匹配 prev*? 0个或多个 prev，尽可能少地匹配 prev+ 1个或多个 prev，尽可能多地匹配 prev+? 1个或多个 prev，尽可能少地匹配 prev{ m} m个连续的 prev prev{ m, n} m到 n个连续的 prev，尽可能多地匹配 prev{ m, n}? m到 n个连续的 prev，尽可能少地匹配
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 4954
</div>
<div class="noteText">
[abc] a或 b或 c（和 a| b| c一样） [^abc]非（ a或 b或 c） prev (?=next)如果后面为 next，返回 prev prev (?!next)如果后面非 next，返回 prev (?<=prev) next如果前面为 prev，返回 next (?<!prev) next如果前面非 prev，返回 next
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 5029
</div>
<div class="noteText">
正则表达式的语法可能会与 Python本身的语法冲突。例如，我们期望下面例子中的模式能匹配任何以 fish开头的词： >>> re. findall('\ bfish', source) []为什么没有匹配成功？第 2章曾提到， Python字符串会使用一些特殊的转义符。例如上面的 \b，它在字符串中代表退格，但在正则表达式中，它代表一个单词的开头位置。因此，把 Python的普通字符串用作正则表达式的模式串时需要特别注意，不要像上面一样与转义符产生冲突。
</div>
<div class="sectionHeading">
7.2.4　使用binascii()转换字节/字符串
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 5243
</div>
<div class="noteText">
使用 binascii()转换字节/字符串
</div>
<div class="sectionHeading">
8.1.5　使用with自动关闭文件
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 5525
</div>
<div class="noteText">
Python的上下文管理器（ context manager）会清理一些资源，例如打开的文件。它的形式为 with expression as variable：
</div>
<div class="sectionHeading">
8.4.3　SQLite
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 6047
</div>
<div class="noteText">
sqlite3. Cursor object at 0x1006a22d0>在 SQL中使用三个问号表示要插入三个值，并把它们作为一个列表传入函数 execute()。这些占位符用来处理一些冗余的细节，例如引用（ quoting）。它们会防止 SQL注入：一种常见的 Web外部攻击方式，向系统插入恶意的 SQL命令。
</div>
<div class="sectionHeading">
9.2.5　Flask
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 7117
</div>
<div class="noteText">
在 URL中使用 GET命令时，传入的参数形式为 &key1= val1& key2= val2&...。你可以使用字典的 **操作符来向模板中一次性传入字典的多个值（把下面的代码存储为 flask3c. py）： from flask import Flask, render_ template, request app = Flask(__ name__) @app. route('/ echo/') def echo(): kwargs = {} kwargs[' thing'] = request. args. get(' thing') kwargs[' place'] = request. args. get(' place') return render_ template(' flask3. html', **kwargs) app. run( port= 9999, debug= True)
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 7126
</div>
<div class="noteText">
**kwargs的行为与 thing= thing和 place= place一样，但是在参数很多时可以少输入很多内容。
</div>
<div class="sectionHeading">
11.1.3　线程
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 8032
</div>
<div class="noteText">
使用线程来解决 I/ O限制问题；使用进程、网络或者事件（下一节会介绍）来处理 CPU限制问题。 11. 1. 4 绿色线程和 gevent如你所见，开发者通常会把程序中运行速度慢的部分划分为多个线程或者进程从而加快速度。 Apache Web服务器就是一个典型的例子。另一种方法是基于事件编程。一个基于事件的程序会运行一个核心事件循环，分配所有任务，然后重复这个循环。 nginx Web服务器就是基于事件的设计，通常来说比 Apache快。
</div>
<div class="sectionHeading">
11.1.4　绿色线程和gevent
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 8075
</div>
<div class="noteText">
比如 socket，直接让它们使用绿色线程而不是调用 gevent版本。如果想在整个程序中应用 gevent，这种方法非常有用，即使那些你无法直接接触到的代码也会被改变。在程序的开头，添加下面的代码： from gevent import monkey monkey. patch_ socket()这会把程序中所有的普通 socket都修改成 gevent版本，即使是标准库也不例外。再提醒一次，这个改动只对 Python代码有效，对 C写成的库无效。
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 8085
</div>
<div class="noteText">
另一个函数会给更多的标准库模块打上补丁： from gevent import monkey monkey. patch_ all()
</div>
<div class="sectionHeading">
11.1.8　队列之上
</div>
<div class="noteHeading">
标注 (<span class="highlight_pink">粉色</span>) -  位置 8224
</div>
<div class="noteText">
队列之上加入的功能越多，流水线就越有可能出问题。如果需要给一个宴会洗盘子，工人数量是否足够呢？如果烘干工人喝多了怎么办？如果水槽堵了怎么办？好担心啊！如何应对这一切呢？幸运的是，有三种技术可供你使用。触发并忘记只传递内容，并不关心结果，即使没人处理。这就是“把盘子扔地上”方法。请求 -响应对于每一个盘子，流水线上的清洗工人需要收到烘干工人的确认，烘干工人需要收到放置工人的确认。背压或者节流适用于上游工人速度比下游工人快的情况。在真实系统中，你必须保证工人的速度能够满足需求，否则就会听到盘子摔碎的声音。你可以把新任务添加到一个等待列表中，一些工人进程会从中弹出最后一个消息并把它添加到工作列表中。消息处理完成后会从工作列表中移除并被添加到完成列表。这样就可以知道哪些任务失败或者占用了太长的时间。你可以自己使用 Redis来完成这些功能，或者使用其他人已经写好并通过测试的系统。以下有一些基于 Python的队列包添加了这种额外的控制层（有些使用的是 Redis）。 celery（ http:// www. celeryproject. org/）
</div>
<div class="sectionHeading">
11.2.5　ZeroMQ
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 8474
</div>
<div class="noteText">
我们已经看过如何用 ZeroMQ套接字创建发布 -订阅模型。 ZeroMQ是一个库，有时候也被称为打了激素的套接字（ sockets on steroids）， ZeroMQ套接字实现了很多你需要但是普通套接字没有的功能：
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 8485
</div>
<div class="noteText">
REQ（同步请求） REP（同步响应） DEALER（异步请求） ROUTER（异步响应） PUB（发布） SUB（订阅） PUSH（扇出） PULL（扇入）
</div>
<div class="noteHeading">
书签 -  位置 8489
</div>
<div class="noteHeading">
书签 -  位置 8503
</div>
<div class="noteHeading">
书签 -  位置 8565
</div>
<div class="sectionHeading">
11.2.8　Web服务和API
</div>
<div class="noteHeading">
标注 (<span class="highlight_blue">蓝色</span>) -  位置 8637
</div>
<div class="noteText">
英语“不安分”是 restless，正好和 RESTful对应。——译者注
</div>
<div class="sectionHeading">
11.2.9　远程处理
</div>
<div class="noteHeading">
书签 -  位置 8667
</div>
<div class="noteHeading">
书签 -  位置 8692
</div>

        </div>
    </body>
</html>
